Aula 14 ‚Äì Vetores

VARI√ÅVEIS COMPOSTAS

As vari√°veis simples s√£o alocadas na mem√≥ria de acordo com as necessidades do Sistema Operacional.

--- Vari√°vel composta homog√™nea

A Vari√°vel composta homog√™nea chama-se assim porque todos os itens dela s√£o do mesmo tipo (no exemplo, abaixo, Inteiro)

n: vetor[1..4] de inteiro

As vari√°veis simples s√£o alocadas um tanto quanto espar√ßadas ou aleatoriamente, enquanto as vari√°veis compostas tem sua aloca√ß√£o uma seguida da outra na mem√≥ria. No caso acima, √© uma vari√°vel com 4 valores(espa√ßos na mem√≥ria).

n[1] <- 3 // n na posi√ß√£o 1 recebe o valor 3.

Entre colchetes fica o √≠ndice.

--- Vari√°vel composta homog√™nea unidimensional

A uma Vari√°vel composta homog√™nea unidimensional d√°-se o nome de VETOR.

    algoritmo "TesteVetor"
    var
        v: vetor[1..6] de Inteiro
        c: Inteiro
    inicio
        Para c <-1 ate 6 faca
            Escreva("Digite o", c,"o.valor")
            Leia(v[c])
        FimPara
        
        Para c<-1 ate 6 faca
            Escreva("{",v[c],"}")
        FimPara
    fimalgoritmo

--

Ele passou um exemplo de mostrar os total de pares em um vetor de 7 posi√ß√µes.

Diz ele que a verdadeira utilidade dos vetores √© conseguir armazenar os valores. Por conta da posi√ß√£o dos items, o √≠ndice deles. O que n√£o √© poss√≠vel numa vari√°vel simples. O fato de ter v√°rios espa√ßos armazen√°veis em uma mesma vari√°vel, pois na vari√°vel simples o valor deve ser substitu√≠do.

Ele passou um exemplo de listagem de uma turma, com nome de aluno, nota 1, nota 2 e media (todos vetores de mesmo tamanho). Eu n√£o ia copiar, mas ele passou um macete que deve ter em outras linguagens, mas n√£o me foi ensinado e nunca vi ningu√©m usar (se vi, n√£o foi com essa facilidade).

    algoritmo "Turma"
        var
        nome: vetor[1..4] de Caractere
        n1: vetor[1..4] de Real
        n2: vetor[1..4] de Real
        m: vetor[1..4] de Real
        i: Inteiro

    inicio
        Para i <- 1 ate 4 faca
            Escreval("ALUNO",i)
            Escreva("Nome: ")
            Leia(nome[i])
            Escreva("Primeira Nota:")
            Leia(n1[i])
            Escreva("Segunda Nota:")
            Leia(n2[i])
            m[i] <- (n1[i]+n2[i]/2)
        FimPara
        
        LimpaTela
            Escreval("LISTAGEM DE ALUNOS")
            Escreval("------------------")
            Para i <- 1 ate 4 faca
                Escreval(nome[i]:15, m[i])
        FimPara
    fimalgoritmo

O bizu est√° aqui:

    Escreval(nome[i]:15, m[i]:4:1)

Aquele ':15' depois do vetor faz com que caso o nome n√£o use 15 espa√ßos, o restante ser√° preenchido com espa√ßos em branco. Isso alinhar√° o pr√≥ximo item com muita facilidade. E mais! Eu testei agora com nomes maiores do que 15 espa√ßos, e simplesmente os caracteres excedentes foram suprimidos de aparecer, por√©m eles ainda permancem constando na vari√°vel.

E em 'm' ele colocou ainda ':4:1', sendo 4 espa√ßos ao todo e uma decimal. Ou seja, dois n√∫meros, um ponto e uma decimal.

----- ChatGPT sobre o fato de o Visualg ter permitido extrapolar o valor de 4 casas com o valor 20000.0 usado como exemplo -----

O que realmente acontece no Visualg

üëâ O Visualg N√ÉO corta nem gera erro quando o n√∫mero √© maior que a largura definida.

Em vez disso:

O 4 funciona como largura m√≠nima, n√£o m√°xima

Se o n√∫mero precisar de mais espa√ßo, o Visualg expande o campo automaticamente

Exemplo

C√≥digo:

Escreval(m[i]:4:1)


Valores e sa√≠das:

Valor	Sa√≠da
3.2	3.2
25.8	25.8
20000.0	20000.0

Nenhuma inconsist√™ncia, nenhum erro.

Ent√£o pra que serve o 4?

Ele s√≥ √© √∫til quando:

Voc√™ est√° organizando colunas

Os valores normalmente cabem naquele espa√ßo

Quer alinhamento visual

‚ö†Ô∏è Importante

Visualg √© bem permissivo:

N√£o lan√ßa erro

N√£o trunca valores

Prioriza mostrar o n√∫mero completo

üß† Conclus√£o

‚úîÔ∏è O resultado est√° correto
‚úîÔ∏è N√£o h√° inconsist√™ncia
‚úîÔ∏è O formato n√£o imp√µe limite, s√≥ sugere

----- Fim do ChatGPT sobre o fato de o Visualg ter permitido extrapolar o valor de 4 casas com o valor 20000.0 usado como exemplo -----

Esta foi uma sa√≠da teste que fiz:

------------------
Mario Antonio V 2.0
Carlos Antonio  2.0
Bianca de Moral350000.0
Teddy          10.0

Ou seja, foram delimitados 15 espa√ßos de caracteres e depois 4 caracteres com o ponto como o espa√ßo padr√£o seguinte.

------------------
alfredo        6790122.5alfre
ww             678.5ww   
e                1.5e    
e                2.0e

Acima √© o retorno disto:

    Escreval(nome[i]:15, m[i]:5:1,nome[i]:5)

Portanto, √© poss√≠vel concluir que ele permite o extravazamento de n√∫meros do lado esquerdo do ponto, mas n√£o de caracteres. Esse extravazamento empurra o restante adiante. Que continuar√£o seguindo suas regras de compacta√ß√£o.

N√£o testarei adiante, com mais colunas.

----

Depois ele complementou mostrando o total de alunos com nota acima da m√©dia da turma.


Ele fez um exemplo tamb√©m que receber√° somente os nomes que come√ßarem com a letra C. Abaixo:

    algoritmo "SoComC"
    var
        nome: Caractere
        soC: vetor[1..10] de Caractere
        c, tot: Inteiro
    inicio
        tot <- 0
        Para c <- 1 ate 10 faca
            Escreva("Digite seu nome:")
            Leia(nome)
            Se (copia(maiusc(nome),1,1)= "C") entao
                tot <-tot + 1
                soC[tot] <- nome
            FimSe
        FimPara
        
        LimpaTela
        Escreval("LISTAGEM FINAL")
        Para c <- 1 ate tot faca
            Escreval(soC[c])
        FimPara
        
    fimalgoritmo


Esse c√≥digo faz com que sejam armanezadas strings com in√≠cio C nas posi√ß√µes, em ordem crescente.

NOTA: Como o vetor √© de string, enquanto n√£o preenchidas as string, elas s√£o preenchidas com "" (string vazia). Percebi pelo teste de mesa do Visualg.

[Eu achei que n√£o ia copiar muito, mas os exemplos s√£o √≥timos. A maneira que ele armazenou no vetor √© bem interessante, usando o valor de tot para a posi√ß√£o.]

--

Ele passou um exemplo de ordena√ß√£o de vetor, que compara todas as posi√ß√µes com todas as posi√ß√µes consecutivas dela (as depois dela).

A 1a √© comparada com a 2a, a 3a e com a 4a.

5906

5 √© maior igual a 9? N√£o, ent√£o fica.
5 √© maior igual a 0? Sim, ent√£o troca.
5 √© maior igual a 6? N√£o, ent√£o fica.

N√£o h√° necessidade de comparar o 9 com a primeira posi√ß√£o, porque como o 5 se comparou com todas anteriormente.

9 √© maior igual a 5? Sim, ent√£o troca.
9 √© maior igual a 6? Sim, ent√£o troca.


    algoritmo "OrdenaVetor"
    var
        vet: vetor[1..4] de Inteiro
        i, j,aux: Inteiro
    inicio
        Para i <- 1 ate 4 faca
            Escreva("Digite um valor:")
            Leia(vet[i])
        FimPara
        
        Para i <- 1 ate 3 faca // 3, que √© o total(4) menos 1
                Para j <- i+1 ate 4 faca
                    Se(vet[i] > vet[j]) entao
                                aux <- vet[i]
                                vet[i] <- vet[j]
                                vet[j] <- aux
                    FimSe
                FimPara
        FimPara
        
        Para i <-1 ate 4 faca
            Escreva("{",vet[i],"}")
        FimPara
    fimalgoritmo

O nome dela √© "Ordena√ß√£o por Sele√ß√£o (Selection Sort)."

Se fosse "Bubblesort" a linha:

    Para j <- i+1 ate 4 faca

Seria:

    Se (vet[j] > vet[j+1]) entao

O Bubblesort compara elementos vizinhos. Ele √© menos eficiente. Mas tem o Bubblesort otimizado (IA que me passou kkkk) que coloca uma flag false antes do for do 'j' e sinaliza ela como true de volta se a condi√ß√£o dentro do 'for' do 'j' for true. Teria que analisar se √© otimizado mesmo. Eu fiz um pouco do teste de mesa, mas n√£o fiquei comparando.

O C√ìDIGO 

    algoritmo "BubbleSortOtimizado"
var
    vet: vetor[1..4] de Inteiro
    i, j, aux: Inteiro
    trocou: Logico
inicio
    Para i <- 1 ate 4 faca
        Escreva("Digite um valor:")
        Leia(vet[i])
    FimPara

    Para i <- 1 ate 3 faca
        trocou <- Falso
        Para j <- 1 ate 4 - i faca
            Se (vet[j] > vet[j+1]) entao
                aux <- vet[j]
                vet[j] <- vet[j+1]
                vet[j+1] <- aux
                trocou <- Verdadeiro
            FimSe
        FimPara

        Se (trocou = Falso) entao
        FimSe
    FimPara

    Para i <- 1 ate 4 faca
        Escreva("{", vet[i], "}")
    FimPara
fimalgoritmo

Ele prop√¥s um exercicio para colocar uma tabela de times em que um time n√£o pode jogar contra ele mesmo (obviamente).

Outro √© de corre√ß√£o de provas. A√≠ mostra os nomes dos alunos, notas e m√©dia da turmas, mas usando vetores. Daria para hierarquizar as posi√ß√µes dos alunos conforme as notas tamb√©m...

Outro √© de Reserva de cadeiras no cinema. Ele faz com o que o valor do item fique como "---" quando for ocupado. N√£o gostei, mas entendi. Porque voc√™ depois pode reiniciar o vetor para uma nova sess√£o criando uma fun√ß√£o de cria√ß√£o dos lugares novamente. Mas isso a√≠ √© mais para aprender. O certo √© botar uma flag "ocupado <- Verdadeiro".

N√£o farei esses.

[A aula tem 40 min, tomei 3 horas.]